syntax = "proto3";

option java_multiple_files = true;
option java_package = "marmot.proto.service";

package marmot.proto.service;

import public "marmot.proto";
import public "marmot.optor.proto";
import public "marmot.service.proto";


service RecordSetService {
	// 다음번 레코드 뭉치를 반환한다.
	rpc getNextRecordBulk(NextBulkRequest) returns (stream RecordBulkResponse);
	
	// 레코드세트 업로드를 위한 업로드용 레코드세트를 할당한다.
	// 할당된 레코드세트의 식별자를 반환함.
	rpc allocateRecordSet(RecordSchemaProto) returns (StringResponse);
	rpc uploadRecordSet(stream UploadRecordRequest) returns (stream UploadRecordResponse);
	
	// 식별자에 해당하는 레코드세트 등록을 해제하고 할당된 장원을 반환한다.
	rpc close(StringProto) returns (VoidResponse);
}

message NextBulkRequest {
	string rset_id = 1;		// 레코드세트 식별자.
	int32 bulk_size = 2;	// 레코드 뭉치 크기 (레코드 갯수)
}
message RecordBulkResponse {
	oneof either {
		marmot.proto.RecordProto record = 1;	// 요청 레코드를 전송
		VoidProto end_of_stream = 2;			// 레코드세트 전송을 모두 마친 경송
		ErrorProto error = 3;					// 전송측(클라이언트측) 오류가 발생한 경우.
	}
}


message UploadRecordRequest {
	// 하나 이상의 request 메세지가 전송됨.
	// 첫 메시지는 'rset_id'를 보내, 업로드된 레코드가 적재될 레코드세트의 식별자를 제공함.
	// 그 뒤부터는 업로드할 record를 반복적으로 전달함. 일정 수(예: 16개)의 레코드 전송 후
	// 그때까지 전송한 전체 레코드 수를 'sync' 메시지를 통해 전송한 뒤, UploadRecordResponse 메시지에
	// 동일한 값의 'sync_ack' 메시지가 도착할 때까지 레코드 전송을 대기시킴.
	// 만일 업로드하는 쪽에서 오류가 발생되어 더 이상 메세지를 보낼 수 없는
	// 경우는 'error'를 전송하고 종료함.
	oneof either {
		string rset_id = 1;	// 업로드 대상 레코드세트 식별자 (header)
		RecordProto record = 2;			// 업로드 시킬 레코드
		int64 sync = 3;
		ErrorProto error = 4;			// 업로드 중 클라이언트쪽에서 오류가 발생된 경우
	}	
}
message UploadRecordResponse {
	oneof either {
		int64 sync_ack = 1;				// 클라이언트에서 보낸 ack값을 그대로 반환
		VoidProto rset_closed = 2;		// 업로드 중인 서버쪽 RecordSet이 이미 닫힌 경우
		ErrorProto error = 3;			// 업로드 중 서버쪽에서 오류가 발생된 경우
	}
}